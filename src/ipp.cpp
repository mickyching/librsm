
#include <sstream>
#include <fstream>
#include <iostream>
#include <cstring>
#include "ipc.h"
#include "ipp.h"
#include "config.h"
#include "simstr.h"

const std::string Ipp::IPP_ASCII              = "ipp ascii";
const std::string Ipp::IPP_SUFFIX             = ".ipp";

Ipp* Ipp::_self = NULL;
display::State Ipp::_state;


gboolean Ipp::is_ipp_filename(const std::string& fname)
{
    return fname.rfind(IPP_SUFFIX) == fname.length() - IPP_SUFFIX.length();
}

void Ipp::displayfunc()
{
    display::display(_state);
}


void Ipp::reshapefunc(int width, int height)
{
    display::reshape(_state, width, height);
}


void Ipp::mousefunc(int button, int state, int x, int y)
{
    display::mouse(_state, button, state, x, y);
}


void Ipp::keyboardfunc(unsigned char key, int x, int y)
{
    display::keyboard(_state, key, x, y);
}


void Ipp::specialfunc(int key, int x, int y)
{
    display::special(_state, key, x, y);
}


void Ipp::motionfunc(int x, int y)
{
    display::motion(_state, x, y);
}


gdouble Ipp::side_interval() const
{
    gdouble side = 0.0;
    if (_np.method == Ncparams::ISO_PLANAR) side = _np.ippside;
    else if (_np.method == Ncparams::ISO_LAYER) side = _np.ilpside;
    return side;
}


namespace
{
    void avertex_into_bbox(Vertex* v, GtsBBox* bbox)
    {
        v->enlarge_bbox(*bbox);
    }
}
GtsBBox* Ipp::gen_bbox(GtsBBoxClass* bbclass) const
{
    GtsBBox* b = gts_bbox_new(bbclass, NULL, 0., 0., 0., 0., 0., 0.);
    b->x1 = b->y1 = b->z1 = G_MAXDOUBLE;
    b->x2 = b->y2 = b->z2 = -G_MAXDOUBLE;
    foreach_vertex((GtsFunc) avertex_into_bbox, b);
    return b;
}


void Ipp::foreach_vertex(GtsFunc f, gpointer data) const
{
    for (const_iterator iter = _ipp.begin(); iter != _ipp.end(); ++iter)
    {
        for (planar::const_iterator pi = iter->begin(); pi != iter->end(); ++pi) {
            f(*pi, data);
        }
    }
}


void Ipp::foreach_vertex(GtsFunc f, gpointer data)
{
    for (iterator iter = _ipp.begin(); iter != _ipp.end(); ++iter)
    {
        for (planar::iterator pi = iter->begin(); pi != iter->end(); ++pi) {
            f(*pi, data);
        }
    }
}


void Ipp::read(const std::string& fname)
{
    g_return_if_fail(is_ipp_filename(fname));
    std::ifstream fin(fname.c_str());
    read(fin);
    fin.close();
}


void Ipp::read(std::istream& is)
{
    destroy();
    std::string line;
    get_valid_line(is, line);
    g_return_if_fail(line == IPP_ASCII);

    std::stringstream ss;
    guint size;

    get_valid_line(is, line);
    ss.clear();
    ss.str(line);
    ss >> size;

    char c;
    gdouble x, y, z;

    for (guint i = 0; i != size; ++i) {
        planar vlist;

        get_valid_line(is, line);
        g_return_if_fail(line[0] == '{');
        ss.clear();
        ss.str(line);
        ss >> c >> y;

        while (get_valid_line(is, line)) {
            if (line[0] == '}') break;
            ss.clear();
            ss.str(line);
            ss >> x >> z;
            Vertex* v = vertex_new(vertex_class(), x, y, z);
            vlist.push_back(v);
        }
        _ipp.push_back(vlist);
    }
}


void Ipp::write(const std::string& fname) const
{
    g_return_if_fail(is_ipp_filename(fname));
    std::ofstream fout(fname.c_str());
    write(fout);
    fout.close();
}


void Ipp::write(std::ostream& out) const
{
    out << Ipp::IPP_ASCII << "\n"
        << RE_COMMENT << " iso planar path\n"
        << RE_COMMENT << " generated by " << PACKAGE_STRING << "\n"
        << RE_COMMENT << " developed by " << PACKAGE_BUGREPORT << "\n"
        << _ipp.size() << "\n";

    gdouble side = side_interval();
    g_return_if_fail(side > 0.0);

    const_iterator iter = _ipp.begin();
    for (gdouble ypos = _np.ymin; ypos <= _np.ymax; ypos += side, ++iter)
    {
        g_return_if_fail(iter != _ipp.end());
        out << "{ " << ypos << "\n";
        planar::const_iterator pi = iter->begin();
        while (pi != iter->end())
        {
            GtsPoint* p = GTS_POINT(*pi);
            out << "  " << p->x << " " << p->z << "\n";
            ++pi;
        }
        out << "}\n";
    }
}


void Ipp::write_gcode(const std::string& fname) const
{
    std::ofstream fout(fname.c_str());
    write_gcode(fout);
    fout.close();
}


void Ipp::write_gcode(std::ostream& out) const
{
    g_return_if_fail(_np.method == Ncparams::ISO_PLANAR);
    out.setf(std::ios::fixed, std::ios::floatfield);
    out.precision(3);
    guint line_num = 0;

    out << "N" << ++line_num << " G71 G90\n";
    write_ipp_gcode(out, &line_num);
    out << "N" << ++line_num << " G00 Z" << _np.zmax + _np.rise_height << "\n";
}


void Ipp::write_ipp_gcode(std::ostream& osm, guint* nline) const
{
    g_return_if_fail(nline != NULL);
    g_return_if_fail(!is_empty());

    gdouble x0, y0;
    for (const_iterator iter = begin(); iter != end(); ++iter) {
        if (!iter->empty()) {
            planar::const_iterator pi = iter->begin();
            GtsPoint* p1 = GTS_POINT(*pi);
            x0 = p1->x;
            y0 = p1->y;
            break;
        }
    }

    bool last_loop = false;
    gdouble zmin = _np.zmin,    zmax = _np.zmax;
    gdouble zbeg = _np.ippzmax, zend = _np.ippzmin;
    gdouble feed = _np.ippfeed, rize = _np.ipprize;

    for (gdouble depth = zbeg; !last_loop; depth -= feed) {
        if (depth <= zend) {
            last_loop = true;
            depth = zend;
        }

        write_G0(osm, nline) << "Z" << zmax + _np.rise_height << "\n";
        write_G0(osm, nline) << "X" << x0 << " Y" << y0 << "\n";
        write_G0(osm, nline) << "Z" << depth + feed + rize << "\n";

        bool path_back = false;
        for (const_iterator iter = begin(); iter != end(); ++iter) {
            if (path_back) {
                for (planar::const_iterator pi = iter->begin();
                        pi != iter->end(); ++pi) {
                    GtsPoint* p1 = GTS_POINT(*pi);
                    gdouble x = p1->x, y = p1->y, z = p1->z;
                    z = z > depth ? z + rize : depth + rize;
                    osm << "N" << ++(*nline) << " G01"
                        << " X" << x << " Y" << y << " Z" << z << "\n";
                }
                path_back = false;
            }
            else {
                for (planar::const_reverse_iterator pi = iter->rbegin();
                        pi != iter->rend(); ++pi) {
                    GtsPoint* p1 = GTS_POINT(*pi);
                    gdouble x = p1->x, y = p1->y, z = p1->z;
                    z = z > depth ? z + rize : depth + rize;
                    osm << "N" << ++(*nline) << " G01"
                        << " X" << x << " Y" << y << " Z" << z << "\n";
                }
                path_back = true;
            }
        }
    }
}
namespace
{
    gint edge_cmp_x(Edge* e1, Edge* e2)
    {
        g_return_val_if_fail(e1 != NULL && e2 != NULL, 0);
        GtsPoint* p1 = e1->v1()->p();
        GtsPoint* p2 = e2->v1()->p();
        if (p1->x > p2->x) return +1;
        if (p1->x < p2->x) return -1;
        return 0;
    }

    void edge_sort_x(Edge* e, gpointer)
    {
        g_return_if_fail(e != NULL);
        GtsPoint* p1 = GTS_POINT(e->v1());
        GtsPoint* p2 = GTS_POINT(e->v2());
        if (p1->x > p2->x) e->vertex_swap();
    }

    void vertex_slist_buid(Edge* edge, Ipp::planar* vlist)
    {
        g_return_if_fail(edge != NULL && vlist != NULL);
        GtsPoint* p1 = GTS_POINT(EDGE(edge)->v1());
        GtsPoint* p2 = GTS_POINT(EDGE(edge)->v2());
        Vertex* va = vertex_new(vertex_class(), p1->x, p1->y, p1->z);
        Vertex* vb = vertex_new(vertex_class(), p2->x, p2->y, p2->z);
        vlist->push_back(va);
        vlist->push_back(vb);
    }

    bool is_vertex_less_x(Vertex* v1, Vertex* v2)
    {
        g_return_val_if_fail(v1 != NULL && v2 != NULL, 0);
        GtsPoint* p1 = GTS_POINT(v1);
        GtsPoint* p2 = GTS_POINT(v2);
        if (p1->x < p2->x) return true;
        return false;
    }

    bool is_vertex_samex(Vertex* v1, Vertex* v2)
    {
        GtsPoint* p1 = GTS_POINT(v1);
        GtsPoint* p2 = GTS_POINT(v2);
        if (ABS(p1->x - p2->x) < Vertex::EPSILON) return true;
        return false;
    }

    void vertex_unique_x(Ipp::planar& vlist)
    {
        if (vlist.empty()) return;
        Ipp::planar::iterator vpos = vlist.begin(), next = vlist.begin();
        ++next;
        while (vpos != vlist.end() && next != vlist.end())
        {
            if (is_vertex_samex(VERTEX(*vpos), VERTEX(*next))) {
                gts_object_destroy(GTS_OBJECT(*next));
                next = vlist.erase(next);
                continue;
            }
            ++vpos;
            ++next;
        }

    }

    void vertex_update_z(Vertex* v, Edge* e)
    {
        GtsPoint* p1 = GTS_POINT(e->v1());
        GtsPoint* p2 = GTS_POINT(e->v2());
        GtsPoint* pi = GTS_POINT(v);
        g_return_if_fail(pi->x + Vertex::EPSILON > p1->x);
        g_return_if_fail(pi->x - Vertex::EPSILON < p2->x);
        if (ABS(pi->x - p1->x) < Vertex::EPSILON && pi->z < p1->z) pi->z = p1->z;
        if (ABS(pi->z - p2->x) < Vertex::EPSILON && pi->z < p2->z) pi->z = p2->z;
        if (ABS(p2->x - p1->x) < Vertex::EPSILON) return;
        gdouble z = (pi->x - p1->x) * (p2->z - p1->z)/(p2->x - p1->x) + p1->z;
        if (pi->z < z) pi->z = z;
    }

    void mono_chain(Ipp::planar& vlist, GSList* elist)
    {
        Ipp::planar::iterator vpos = vlist.begin();
        GSList *epos = elist;
        while (vpos != vlist.end() && epos != NULL) {
            Edge* e = EDGE(epos->data);
            GtsPoint* p1 = e->v1()->p(), *p2 = e->v2()->p();
            GtsPoint* pi = NULL;
            g_return_if_fail(p1->x <= p2->x);

            while (vpos != vlist.end()) {
                pi = GTS_POINT(*vpos);
                if (pi->x + Vertex::EPSILON < p1->x) ++vpos;
                else break;
            }

            Ipp::planar::iterator i = vpos;
            while (i != vlist.end())  {
                pi = GTS_POINT(*i);
                if (pi->x - Vertex::EPSILON > p2->x) break;
                vertex_update_z(*i, e);
                ++i;
            }
            epos = epos->next;
        }
    }

} // end namespace


void Ipp::make_path(const Surface& s)
{
    Ipc ipc(_np);
    ipc.make_curves(s);
    _ipp.reserve(ipc.planar_number());

    for (Ipc::iterator iter = ipc.begin(); iter != ipc.end(); ++iter)
    {
        g_slist_foreach(*iter, (GFunc) edge_sort_x, NULL);
        *iter = g_slist_sort(*iter, (GCompareFunc) edge_cmp_x);

        planar vlist;
        g_slist_foreach(*iter, (GFunc) vertex_slist_buid, &vlist);
        vlist.sort(is_vertex_less_x);
        vertex_unique_x(vlist);

        mono_chain(vlist, *iter);

        _ipp.push_back(vlist);
    }

    if (_np.figure == Ncparams::RECTANGLE) {
        add_rectangle_border(vertex_class(), edge_class());
    }
    else if (_np.figure == Ncparams::ELLIPES) {
        add_ellipse_border(vertex_class(), edge_class());
    }
    else;// 默认不添加边界
}


void Ipp::gen_lines_list(display::State& stt)
{
    glNewList(stt.line_list, GL_COMPILE);

    glLineWidth(2.0);
    glColor3f(0.0, 0.0, 0.5);

    glBegin(GL_LINES);
    for (const_iterator iter = begin(); iter != end(); ++iter) {
        g_return_if_fail(!iter->empty());
        GtsPoint* p1 = NULL, *p2 = NULL;
        planar::const_iterator pi = iter->begin();
        if (pi != iter->end()) {
            p1 = GTS_POINT(*pi);
        }
        for (++pi; pi != iter->end(); ++pi) {
            p2 = GTS_POINT(*pi);
            glVertex3f(p1->x, p1->y, p1->z);
            glVertex3f(p2->x, p2->y, p2->z);
            p1 = p2;
        }
    }
    glEnd();

    glEndList();
}


void Ipp::show(GLenum mode)
{
    _self = this;
    _state.draw_mode = mode;
    display::show_init(*_self, _state);
    if (_state.draw_mode & display::POINTS) list_points(_state, *_self);
    if (_state.draw_mode & display::LINES)  _self->gen_lines_list(_state);
    //list_axis(_state, 1.0, 1.0, 1.0);

    glutDisplayFunc(displayfunc);
    glutReshapeFunc(reshapefunc);
    glutMouseFunc(mousefunc);
    glutKeyboardFunc(keyboardfunc);
    glutSpecialFunc(specialfunc);
    glutMotionFunc(motionfunc);
    //glutIdleFunc(idlefunc);
    glutMainLoop();

}




void Ipp::add_rectangle_border(VertexClass* vclass, EdgeClass* eclass)
{
    gdouble side = side_interval();
    g_return_if_fail(side > 0.0);
    gdouble xmin = _np.xmin, xmax = _np.xmax, ymin = _np.ymin, ymax = _np.ymax,
            zmin = _np.zmin;

    iterator iter = _ipp.begin();
    for (gdouble ypos = ymin; ypos <= ymax; ypos += side, ++iter) {
        g_return_if_fail(iter != _ipp.end());
        if (iter->empty()) {
            Vertex* v1 = vertex_new(vertex_class(), xmin, ypos, zmin);
            Vertex* v2 = vertex_new(vertex_class(), xmax, ypos, zmin);
            iter->push_back(v1);
            iter->push_back(v2);
            continue;
        }
        GtsPoint* pbeg = GTS_POINT(*iter->begin());
        GtsPoint* pend = GTS_POINT(*iter->rbegin());
        if (pend->x < xmax) {
            Vertex* v1 = vertex_new(vertex_class(), pend->x, ypos, zmin);
            Vertex* v2 = vertex_new(vertex_class(), xmax, ypos, zmin);
            iter->push_back(v1);
            iter->push_back(v2);
        }
        if (pbeg->x > xmin) {
            Vertex* v1 = vertex_new(vertex_class(), xmin, ypos, zmin);
            Vertex* v2 = vertex_new(vertex_class(), pbeg->x, ypos, zmin);
            iter->push_front(v2);
            iter->push_front(v1);
        }
    }
}


void Ipp::add_ellipse_border(VertexClass* vclass, EdgeClass* eclass)
{
    gdouble side = side_interval();
    g_return_if_fail(side > 0.0);

    gdouble midx = (_np.xmax + _np.xmin) / 2.0;
    gdouble midy = (_np.ymax + _np.ymin) / 2.0;
    gdouble rx = midx - _np.xmin;
    gdouble ry = midy - _np.ymin;

    iterator iter = _ipp.begin();
    for (gdouble ypos = _np.ymin; ypos <= _np.ymax; ypos += side, ++iter) {
        g_return_if_fail(iter != _ipp.end());
        gdouble dx = sqrt(rx*rx * (1.0 - (ypos-midy)*(ypos-midy)/(ry*ry)));
        if (iter->empty()) {
            Vertex* v1 = vertex_new(vclass, midx - dx, ypos, _np.zmin);
            Vertex* v2 = vertex_new(vclass, midx + dx, ypos, _np.zmin);
            iter->push_back(v1);
            iter->push_back(v2);
            continue;
        }
        GtsPoint* pbeg = GTS_POINT(*iter->begin());
        GtsPoint* pend = GTS_POINT(*iter->rbegin());
        if (pend->x < midx + dx) {
            Vertex* v1 = vertex_new(vclass, pend->x, ypos, _np.zmin);
            Vertex* v2 = vertex_new(vclass, midx + dx, ypos, _np.zmin);
            iter->push_back(v1);
            iter->push_back(v2);
        }
        if (pbeg->x > midx - dx) {
            Vertex* v1 = vertex_new(vclass, midx - dx, ypos, _np.zmin);
            Vertex* v2 = vertex_new(vclass, pbeg->x, ypos, _np.zmin);
            iter->push_front(v2);
            iter->push_front(v1);
        }
    }
}


namespace
{
    void avertex_destroy(Vertex* v, gpointer)
    {
        gts_object_destroy(GTS_OBJECT(v));
    }
}

void Ipp::destroy()
{
    foreach_vertex((GtsFunc) avertex_destroy, NULL);
    _ipp.clear();
}



